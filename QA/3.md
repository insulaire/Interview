### Redis
1. ##### Redis数据类型有哪些
   1. string ：字符串 
   2. hash：哈希   
   3. list：列表   
   4. set：集合
   5. zset:有序集合 
2. ##### Redis底层数据结构
   1. 字符串：redis使用 SDS（简单动态字符串）作为redis默认字符串表示 
      1. 结构包含 字符串长度、 buf数组存储字符串字节 、buf未使用的数量
   2. 链表：
   3. 字典：
      1. 解决哈希冲突：链地址法
   4. 跳跃表
      1. 插入：抛硬币确定插入的层数，如果是正面就累加 反面就停止。正面出现的次数就是需要插入的层数 底层开始计数
      2. 删除：从每一层查到找元素删除，如果该层只剩头尾节点，则删除该层
      3. 查找：从最高层的链表开始查找，如果遇到该层的下个节点大于查找节点则去当前节点的下一层的下个节点比较，以此类推，直到找到为止
   5. 整数集合
   6. 压缩列表
3. ##### Redis布隆过滤器
   1. 使用场景：有大量数据要判断是否存在大数据集合中
   2. 什么是布隆过滤器：一种数据结构，由一个很长的二进制向量组成。
   3. 添加元素：将要添加的key，用多个hash方法得到hash值，将其值所在的二进制数改为1
   4. 查找元素：将要查找的key，用多个hash方法得到hash值，判断其所在二进制数是否都为1，为1则存在，反之则不存在。
   5. 布隆过滤器可以判断某一数据一定不存在，但无法判断一定存在
   6. 布隆过滤器内的元素 无法删除，但整体占用内存少。
4. ##### Redis的过期策略
   1. 定时删除：
      1. 在设置key的过期时间的同时，创建一个定时器对Key进行删除
      2. 会导致产生很多定时器，影响性能
   2. 惰性删除
      1. key过期后不会主动删除数据，而是等到访问到过期数据的时候进行删除。
      2. 如果很多key过期后都没有被再次访问，会大量堆积导致内存泄露
   3. 定期删除
      1. 隔一段时间执行一次删除操作 循环redis库 在每个库遍历20个key（默认） 如果过期就删除，遍历过程中检测是否到达时间间隔，到了就退出，等待下次检测
      2. 执行的时间间隔太短会影响性能，太长会导致删除不及时，内存释放不够迅速。具体的间隔要看具体服务器和业务属性决定
   4. redis使用的是 惰性删除+定期删除
5. ##### Redis内存淘汰机制
   1. 由 maxmemory-policy 参数配置策略模式
   2. noeviction：不删除，返回错误信息
   3. allkeys-lru：移除最久未使用的key（使用频率少）
   4. volatile-lru：在设置了过期时间key中，删除最久未使用的key
   5. allkeys-random：随机删除key
   6. volatile-random：在设置了过期时间key中，随机删除
   7. volatile-ttl：在设置了过期时间key中，删除快过期的key
   8. allkeys-lfu：移除最近最少使用的key
   9. volatile-lfu：在设置了过期时间key中，移除最近最少使用的key
6.  ##### Redis集群模式有哪些
    1.  主从复制
        1.  一个主节点 多个从节点
        2.  中间通过AOF或者RDB方式同步写指令
    2.  哨兵模式
        1.  由多个哨兵检测主节点是否可用，如果不可用（半数投票不可用则说明不可用）则选举一个从节点当做主节点使用
            1.  由三个定时任务组成
                1.  每10s每个哨兵对主节点和从节点执行info命令，该命令为确定主从关系和发现主节点
                2.  每2s每个哨兵通过主节点的channel交换信息，用来互相交换对节点的意见和自身信息
                3.  每1s每个哨兵对其他哨兵执行和redis执行ping命令，用于心跳检测，作为节点存活的判断依据
            2. 主观下线及客观下线
               1. 主观下线：当前哨兵实例认为redis是不可用状态 SDOWN
                  1. 由哨兵发现redis无法ping通，就认为其不可用
               2. 客观下线：当多数哨兵都认为redis处于不可用状态（SDOWN），这是主节点会被集群定义为ODOWN，将开启故障转移机制
            3. 主动选举：由每个哨兵向其他哨兵发出信号发出我要成为领导者的命令，由半数哨兵同意后，该哨兵成为领导者，如果出现了多位领导者，则会过段时间再次进行选举
            4. 故障转移
               1. 在slave节点中选取一个适合的节点作为主节点
                  1. 选择 slave-priority（slave节点优先级）最高的slave节点，如果存在就返回，不存在就继续下一步
                  2. 选取复制偏移量最大的slave节点（主从复制最完整），如果存在就返回，不存在就继续下一步
                  3. 选择runID最小的slave节点（启动最早的节点）
               2. 对选举出来的slave节点执行 slaveof no one 命令 让其成为新的master
               3. 向其余的slave节点发送命令，让他们成为新master的slave节点
               4. 更新原来的master节点配置为slave，并对其保持关注，一旦恢复后，则让他去复制新master的节点信息
    3.  redis-cluster集群
        1.  由多个主从redis节点组成一个分布式的redis集群
        2.  使用 slot算法 对每个key计算CRC16值 然后对其取模得到对应的hash slot值
        3.  每个redis节点都会分配一段slot值，然后将取模到的数据写入对应的redis节点
        4.  集群支持动态增加或减少redis节点
7. ##### Redis持久化
   1. AOF：redis将收到的每个写命令追加到aof文件中
   2. RDB：在指定的时间间隔内将内存中的数据集快照写入磁盘
      1. RDB比AOF性能好
      2. AOF比RDB更安全更大
      3. AOF文件比RDB文件更新频率高，优先使用AOF
8. ##### Redis分布式锁的实现
   1. 用setnx来抢占锁 同时设置锁过期时间。抢到即获得到锁
   2. 要注意释放锁 要不然会导致锁无法被释放 影响后续操作
   3. 解锁需要使用lua脚本完成，保证redis的执行命令的原子性。先判断key键的value值是否与传入值相等，是则删除，解锁成功
9.  ##### 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？
       1.  ###### 缓存穿透：
           1.  客户端大量访问一个不存在的key，使得流量集中穿透到数据库，导致数据库压力暴增，最后导致数据库宕机。
           2.  对缓存结果为空的key增加过滤
           3.  对查询结果为空的key也增加一层缓存，其过期时间可以设置得比较短
       2. ###### 缓存雪崩：
           1.  缓存在同时大量过期，导致流量全部下放到下游服务，导致服务崩溃
           2.  在设置过期时间时增加随机值，让key不集中过期
           3.  二级缓存，A1为原始缓存 A2为拷贝缓存 A1失效时可以访问A2 A1缓存时间设置为短期，A2为长期
           4.  访问某个key的时候限制其并发量，加锁控制