## 网络通信相关
1. ### TCP 三次握手 四次挥手
   1. ##### 三次握手
      1. 第一次握手：建立连接时，客户端发送SYN包（syn=j）到服务器，并进入 ==SYN_SEED== 状态，等待服务器确认
      2. 第二次握手：服务器收到SYN包，必须确认客户端的SYN（ack=j+1）同时自己也发送一个ACK包（ack=k）即SYN+ACK包 此时服务器进入 ==SYN_RECV== 状态
      3. 第三次握手：客户端收到SYN+ACK包，并向服务器发送确认包ACK（ack=k+1），此时客户端进入 ==ESTABLISHED== 状态 服务端收到ACK包 也进入 ==ESTABLISHED== 状态 完成三次握手
   2. ##### 四次挥手
      1. 第一次挥手：客户端主动断开与服务器连接时，客户端发送FIN包（FIN=m）到服务器，并进入==FIN_WAIT_1==状态，等待服务器确认
      2. 第二次挥手：服务器收到FIN包，必须发送确认客户端的FIN（FIN=m+1）包  客户端收到 FIN（FIN=m+1）包后进入 ==FIN_WAIT_2==状态
      3. 第三次挥手：服务器断开与客户端的连接，服务器进入==LAST_ACK==状态，服务器发送FIN（FIN=N）到客户端
      4. 第四次挥手：客户端接收到FIN包，客户端进入==TIME_WAIT==状态，并向服务器发送确认包ACK（ack=N+1） 服务器进入CLOSE的状态  客户端在==等待2msl时间后自动进入CLOSE==状态
   3. ##### 为什么建立连接时是三次握手 而关闭连接时是四次挥手
        建立连接时，服务器当收到SYN报文后可以将ACK和SYN放在一个报文里面发送。
        而断开连接时，服务器当收到FIN报文后 仅仅代表客户端没有数据发送给服务端，而服务端不一定没有数据发送给客户端，只有等服务端没有数据发送给客户端时服务端才能发送FIN报文给客户端通知客户端关闭连接，所以FIN报文与ACK报文往往是分开发送的。
   4. ##### 为什么客户端要等待2MSL时间后才进入CLOSE状态
        因为网络不可靠，有可能客户端最后发送的ACK报文有可能因为超时导致服务端未收到，而服务端在LAST_ACK状态下未收到客户端的ACK包时会选择重发FIN报文到客户端，而这==2MSL时间就是为了重发的丢失的ACK包==
        


2. ### 什么是HTTP
   1. 一种无连接、无状态、简单快速、灵活的基于TCP/IP的应用层的面向对象的通讯协议，常用于B/S C/S架构上 
   2. ##### HTTP与HTTPS有何不同
      1. 身披SSH外壳的HTTP
      2. 由HTTP通讯，利用SSL/TLS建立安全信道，加密数据包。
      3. 比HTTP更安全，HTTPS有身份验证，通过证书认证客户端访问的是自己的服务器
      4. 保护数据的完整性，防止被中途篡改或冒充
   3. ##### 数据包格式
      1. Request
         1. 请求行：说明请求类型及版本
         2. 请求报头：放服务器要使用的附加信息 
         3. 空行：必须空
         4. 请求正文：请求数据正文 可以是任何格式
         > GET /index.jsp HTTP/1.1
         > Host: 192.168.0.106
         >
         > {
         }
      2. Response
         1. 状态行：HTTP版本、状态码、状态信息
         2. 消息报头：说明客户端要使用的附加信息
         3. 空行：必须
         4. 响应正文：响应数据正文
         >HTTP/1.1 200 OK
         >Date: Mon, 3 Jan 2005 13:13:33 GMT
         >
         >{
         }

   4. ##### 常用的状态有哪些
      1. 200：OK 服务正常
      2. 400：Bad Request 请求出现语法错误
      3. 401：Unauthorized 认证失败
      4. 403：Forbidden 资源不可用
      5. 404: Not Found 资源未找到
      6. 500：Internal Server Error 服务器内部错误
      7. 501: Not Implemented 服务器不支持该请求
      8. 502：Bad Gatway 网关错误
      9. 503：Server Unavailable 服务不可用
      10. 504: Gateway Timeout 网关超时
3. ### 浏览器输入一个网址回车后，发生了什么？
   浏览器会请求DNS服务器获取域名解析的IP，浏览器根据这个IP建立与该服务器的TCP连接，浏览器通过TCP连接发送HTTP请求，服务器收到HTTP请求并返回响应，浏览器根据服务器的返回进行渲染或处理
   1. ##### 网络七层模型
      1. 物理层》数据链路层》网络层》传输层》会话层》表示层》应用层
      2.  物理层：将数据以 比特流 的方式发送与接收 如光缆
      3.  数据链路层：准备数据传输 如网卡
      4.  网络层：管理网络设备，定位设备，决定路由 如路由器 
      5.  传输层：负责分割、组合数据，实现端对端的逻辑连接 三次握手
      6.  会话层：负责建立、维护、控制会话 通信模式
      7.  表示层：负责数据的编码、转换、压缩、解压、加密、解密。
      8.  应用层：确定通信协议，如http ftp smtp 等
   2. ##### 简化为网络五层模型
      1. 物理层》数据链路层》网络层》传输层》应用层
   3. ##### TCP/IP 属于四层模型
      1.  物理链路层》网络层》传输层》应用层
      2.  以太网》IP协议（MAC地址+IP地址）》 TCP、UDP协议（MAC地址+IP地址+端口号）》HTTP、FTP、SSH协议
      3. 数据包
          1.  发送端每经过一层就加一层包，接收端每经过一层就解一层包
          2.  如： 以太网首部（IP首部（TCP首部（HTTP数据（HTTP报文））））
4. ### TCP的拥塞控制
   1. ##### 慢开始与拥塞避免
      1. 发送方维持一个拥塞窗口（cwnd）的状态变量。拥塞窗口大小取决于网络的拥塞程度，并且动态变化，同时维护一个慢开始门限ssthresh状态变量，其数值单位为byte字节
      2. 慢开始：不要刚开始就大量传输数据，而是逐步加大传输 此时窗口每次增长为成倍增长
      3. 拥塞避免：将拥塞窗口增长由倍增变为定量增长，使其有规律的缓慢增长
      4. 当发送方判断出现网络拥塞的时候，拥塞窗口会被重置为1字节,慢开始门限则会被设置为出现拥堵时窗口大小的一半
      5. 当拥塞窗口<慢开始门限时 使用慢开始算法，当拥塞窗口>慢开始门限时 使用拥塞避免算法，相等时随机选择
   2. ##### 快重传和快恢复
      1. 快重传：要求接收方收到一个失序的报文段后就立即发出重复确认，而不是等到主动发送数据的时候捎带确认，其规定发送方只要连续收到三个重复确认就应当立即重传对方尚未收到的报文段，而不是要等到重传时间到后再重传。
      2. 快恢复：当发送方连续收到三个重复确认时，就执行 乘法减小 算法，将慢开始门限减半，拥塞窗口改为与慢开始门限值相等，然后执行拥塞避免算法，使拥塞窗口缓慢增大
   3. ##### TCP怎么认为进入了拥塞状态
      1. 重传了一个报文段，TCP对每个报文段都有一个重传定时器（RTO），当重传定时器超时还未得到数据确认，则TCP就会将该段报文重传。这时候TCP就认为进入了网络拥塞
5.  ### 客户端能连接多少个服务端，反过来服务端能连接多少客户端，为什么，服务端上限是什么决定的
    1.  一个TCP连接：系统用一个四元组来唯一标识一个TCP连接 [local ip,local prot,remote ip remote port]
    2.  客户端连接服务端受到客户端端口限制 tcp的端口数据类型为 unsigned short int 因此本地最大端口为65536个 因为0端口有特殊含义 则可用为65535个
    3.  服务端连接客户端受到客户端IP+客户端端口限制  因此最大为 客户端ip数*客户端端口数 即为 IPV4 2的32次方 * 2的16次方 则服务端能连接2的48次方的客户端 
    4.  实际上服务端也无法达到理论值 linux程序下的限制主要因素为内存和允许的文件描述符 一个socket占用一个文件描述符 一个socket大约占 15-20kb内存
    5.  TCP连出受端口限制, 连入仅受内存限制。
6. 