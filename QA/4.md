### Mysql
1. ##### 事务的四种隔离级别
   1. Serializable  可串行化：避免脏读、不可重复读、幻读的发生 默认配置
   2. Repeatable read 可重复读：可避免脏读、不可重复读的发生
   3. Read committed 读已提交：可避免脏读的发生
   4. Read uncommitted 读未提交：最低情况，任何都无法保证
2. ##### 脏读、幻读、不可重复读
   1. 脏读：A事务提交的数据 B事务读取到 然后A事务回滚后 B读取到的数据就是脏数据。
   2. 幻读：同一事务内两次查询结果条数不同。
   3. 不可重复读：同一事务内两次查询结果数据不一致
   4. 避免不可重复读需要锁行就行，避免幻影读则需要锁表
3. ##### 悲观锁与乐观锁的区别
   1. 悲观锁：对数据被外界修改持悲观态度，在整个数据处理中，该数据都处于锁定状态。
      1. 排他锁：写锁，该数据加锁后，在事务结束前其他事务不能对该数据再增加任何锁，其他事务可读不可写  for update
      2. 共享锁：读锁，该数据加锁后，在事务结束前其他事务都不能对该数据进行修改等操作。 LOCK IN SHARE MODE
   2. 乐观锁：对数据被外界修改持乐观态度，如，在数据处理时会将数据和其版本号一同带出来，修改时判断数据版本是否一致，不一致则更新失败。
4. ##### 为什么用自增序列做索引比较好
   1. 数据记录本身被存于主索引(B+树)的叶子节点上，叶子节点上的数据为按主键顺序排列分布，每当有一条新数据插入时，mysql会根据其主键将其插入适当的节点和位置，每当页面达到装载因子最大值，则开辟新的页存储
   2. 如果主键不是自增序列，因此每次新纪录的插入都要被插入到索引页中的某个位置，此时mysql会不得不为了将数据插入合适的位置而移动数据，这频繁的移动、分页会造成大量的碎片，增加了mysql的开销。
5. ##### ACID靠什么保证
   1. A：Atomicity 原子性 一个事务是不可分割的一部分，要么全成功，要么全失败
      1. 利用innodb的 undo log
      2. undo log为回滚日志，当事务回滚时能撤销所有已经执行成功是sql语句。
   2. C: Consistency 一致性 事务执行前后，数据处于合法状态，其状态与你执行的操作应该是完全一致
      1. 数据库通过 原子性、持久性、隔离性来保持一致性。
   3. I：Isolation 隔离性 多个事务并发时事务内部的操作与其他事务是隔离的，互不影响
      1. 利用锁和MVCC机制
      2. MVCC 多版本并发控制，一条数据有多个版本的快照数据，这些数据保存在 undo log 中。当一个事务处于 update delete操作时，读操作不会等待锁释放，而是读取该行的快照版本。
   4. D：Durability 持久性 事务一旦提交成功，他对数据库的改变就是永久性的，接下来其他操作和故障都不应该对其有任何影响
      1. 利用 innodb的redo log（重做日志）
      2. 当数据修改时，不仅仅在内存中，也会在redo log中记录这次操作。当事务提交时，会将redo log 进行刷盘（redo log 一部分在内存，一部分在硬盘）。当数据库宕机，重启的时候，会将redo log的内容恢复到数据库中。再根据undo log 和binlog内容决定是回滚还是提交数据
6. ##### 聚簇索引与非聚簇索引的区别
   1. 聚簇索引：数据和索引在一起，索引的叶子节点上保存了数据信息 INNODB
   2. 非聚簇索引：索引和数据分开存放，索引的叶子节点上保存了数据对应的位置 MyISAM
   3. 在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，辅助索引叶子节点上存储的不再是行的物理位置，而是存放主键值，然后回主键索引上查找对应数据。（回表查询）
7. ##### B树和B+树的区别
   1.  B树：关键字集合分布在整棵树中，叶子节点不包含任何关键字信息，关键字只会存在一个节点中。
   2.  B+树：关键字集合分布在叶子节点上，非叶节点只是叶子节点中关键字的索引。
   3.  B树只适合随机检索， B+树同时支持随机检索和顺序检索
   4.  B+树的磁盘读写代价更低，其内部节点只保存了关键字信息，内部结构比B树小，其能容纳的关键字信息也比B树多，一次查询的关键字也就比B树多，相对而言，IO次数就会降低，而IO读写次数是影响索引检索效率的最大因素
   5.  B+树的查询效率更加稳定，B树检索可能在非叶子节点结束，越靠近根节点的越快。B+树顺序检索效率明显快，随机检索时，任何关键字查找都必须走根节点到叶子节点的一条路，所有关键字的查找路径长度相同。
   6.  因数据库范围查询比较频繁，所以B+树更适合数据库使用
8.  ##### mysql主从同步怎么做的
    1.  master服务器将数据的改变记录二进制的binlog文件，
    2.  slave服务器会在一定间隔内对master的二进制文件进行探测，如果发生改变，则开启一个I/O线程去请求master二进制事件
    3.  同时master服务器为每个I/O线程启动一个dump线程，用于向其发送binlog，并在本地重放生成relay log文件
    4.  slave会起一个sql线程去逐步访问relay log文件，并解析成sql语句然后一步步执行
9. ##### InnoDB的MVCC实现
   1.  通过保存数据在某个时间节点的快照来实现
   2.  一个事务不管执行多长时间，其看到的内部数据是一致的
   3.  通过在每行记录中保存两个隐藏的列来实现，一个保存行的创建时间，一个保存行的过期/删除时间，该时间是为系统的版本号，每当数据有修改则版本号递增
   4.  insert 保存的创建时间是当时的事务id，delete保存的过期时间是当时操作的事务id，update 操作等于 delete+insert 操作，select操作会查询当前事务id前的数据。